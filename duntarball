#!/bin/bash
#
# Unpack an archive regardless of it's compression format (or lack thereof)
#

# Set usage output
USAGE="[-h |--help] [-p | --patch] [-d <dir> | --directory=<dir>] <archive>"
LONGUSAGE="\t-h, --help\n\t\tPrint this help message
\t-p, --patch\n\t\tExtract twice, once with .orig appended to the dir
\t-d <dir>, --directory=<dir>\n\t\textract to <dir>
\t<archive>\n\t\tPath to archive to extract"

# Standard functions
source ${HOME}/.scripts/functions.sh

# Script name
ME=$(basename $0)

# Parse arguments
ARGS=`getopt -o hpd: --long help,patch,directory: -n "${ME}" -- "$@"`

if [ $? != 0 ] ; then
	usage
fi
eval set -- "$ARGS"

while true ; do
	case "$1" in
		-h|--help) usage; shift ;;
		-p|--patch) PATCH="yes"; shift ;;
		-d|--directory) DIR=$2 ; shift 2 ;;
		--) shift ; break ;;
		* ) usage "Invalid argument $1";;
	esac
done

# Remaining arguments are in $1, $2, etc. as normal
ARCHIVE=${1}

if [ -z ${ARCHIVE} ]; then
	usage "Must give an archive"
fi

TMP=$(tempfile)
atool -xq --save-outdir=$TMP "${ARCHIVE}" 2>/dev/null
DIRNAME=$(cat ${TMP})

if [ -n "${PATCH}" ]; then
	if [ -n "${DIRNAME}" ]; then
		mv "${DIRNAME}" "${DIRNAME}.orig"
		atool -xq "${ARCHIVE}" 2>/dev/null
	else
		die "Failed to extract .orig version: \"${DIRNAME}\""
	fi
fi
echo ${DIRNAME}
rm ${TMP}
# Clean up leftover dirs...
rm -rf Unpack-*
